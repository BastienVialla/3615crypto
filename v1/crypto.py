from pyenigma import enigma
from pyenigma import rotor
import base64
import secrets
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import hashes, padding, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, ec, dh, padding as asym_padding
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, PublicFormat, NoEncryption
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.backends import default_backend

import hashlib
import os

def int_to_bytes(n: int) -> bytes:
    """
    Converts an integer to its corresponding byte representation.

    Args:
        n (int): The integer value to be converted to bytes.

    Returns:
        bytes: The byte representation of the integer in big-endian format.

    Note:
        If n is zero, returns a single byte containing zero (0x00).
    """
    # Convert integer to bytes using big-endian format
    # Calculate the number of bytes needed by taking the bit length of n and rounding up
    return n.to_bytes((n.bit_length() + 7) // 8, byteorder='big')

def caesar_cipher(text, shift, decrypt=False):
    """Chiffre ou déchiffre avec le chiffrement de César."""
    result = ""
    if decrypt:
        shift = -shift
    for char in text:
        if 'a' <= char <= 'z':
            start = ord('a')
            result += chr(start + (ord(char) - start + shift) % 26)
        elif 'A' <= char <= 'Z':
            start = ord('A')
            result += chr(start + (ord(char) - start + shift) % 26)
        else:
            result += char # Garde les autres caractères tels quels
    return result # Retourne des bytes pour la cohérence

def vigenere_cipher(text, key, decrypt=False):
    """Chiffre ou déchiffre avec le chiffrement de Vigenère."""
    result = ""
    key = key.lower()
    key_len = len(key)
    key_index = 0
    for char in text:
        if 'a' <= char <= 'z':
            start = ord('a')
            key_shift = ord(key[key_index % key_len]) - start
            if decrypt:
                key_shift = -key_shift
            result += chr(start + (ord(char) - start + key_shift) % 26)
            key_index += 1
        elif 'A' <= char <= 'Z':
            start = ord('A')
            key_shift = ord(key[key_index % key_len]) - start # Utilise la même clé pour maj/min
            if decrypt:
                key_shift = -key_shift
            result += chr(start + (ord(char) - start + key_shift) % 26)
            key_index += 1
        else:
            result += char
    return result # Retourne des bytes

def enigma_cipher(text, key):
    engine = enigma.Enigma(rotor.ROTOR_Reflector_A, rotor.ROTOR_I,
                                rotor.ROTOR_II, rotor.ROTOR_III, key=key)
    return {'reflector': 'A', 'rotors': [1, 2, 3]}, engine.encipher(text)

def encrypt_aes(message: str, key_size: int = 256, key: bytes = None) -> tuple[bytes, dict]:
    """
    Encrypts a string message using AES-GCM.

    Generates a new key if one is not provided.
    Uses a unique random 12-byte (96-bit) nonce for each encryption.
    The nonce is prepended to the resulting ciphertext. The authentication
    tag generated by GCM is appended automatically by the library.

    Args:
        message: The string message to encrypt.
        key_size: The desired AES key size in bits (128, 192, or 256).
                  Defaults to 256. This is used only when generating a
                  new key (i.e., when 'key' is None).
        key: An optional pre-existing secret key (bytes). If provided,
             its length must be 16, 24, or 32 bytes (for AES-128, AES-192,
             or AES-256 respectively). If None, a new key of 'key_size'
             bits is generated.

    Returns:
        A tuple containing:
        - ciphertext (bytes): The encrypted data, consisting of the 12-byte nonce
                              prepended to the ciphertext and authentication tag.
        - key (bytes): The secret key used for encryption (either the
                       provided one or the newly generated one).

    Raises:
        ValueError: If key_size is invalid when generating a key, or if a
                    provided key has an incorrect length (not 16, 24, or 32 bytes).
        TypeError: If the provided key is not bytes.
    """
    if key is None:
        # --- Key Generation ---
        if key_size not in [128, 192, 256]:
            raise ValueError("Invalid key size. Must be 128, 192, or 256 bits when generating a key.")
        key_bytes_len = key_size // 8
        # Use a cryptographically secure random number generator
        key = os.urandom(key_bytes_len)
    else:
        # --- Key Validation ---
        if not isinstance(key, bytes):
             raise TypeError("Provided key must be of type bytes.")
        key_bytes_len = len(key)
        if key_bytes_len not in [16, 24, 32]: # Corresponds to 128, 192, 256 bits
             raise ValueError(f"Invalid provided key length: {key_bytes_len} bytes. Must be 16, 24, or 32 bytes.")
        # Optional: Warn or error if key_size was explicitly passed and doesn't match len(key)
        # For simplicity here, we just use the length of the provided key.

    # --- Prepare Plaintext ---
    # AES works on bytes, so encode the string message (UTF-8 is common)
    plaintext = message.encode('utf-8')

    # --- Generate Nonce ---
    # GCM requires a unique nonce for every encryption operation with the same key.
    # 12 bytes (96 bits) is recommended by NIST and is efficient.
    # It does NOT need to be secret, just unique. We will prepend it to the ciphertext.
    nonce = os.urandom(12)

    # --- Encryption ---
    # Use AESGCM for authenticated encryption
    try:
        aesgcm = AESGCM(key)
        # Encrypt the plaintext. AESGCM handles padding internally and generates
        # an authentication tag, which it appends to the ciphertext.
        # We pass 'None' for associated data as we are not using it here.
        ciphertext_and_tag = aesgcm.encrypt(nonce, plaintext, None)
    except Exception as e:
        # Catch potential errors during encryption (though less likely with validated key)
        print(f"An error occurred during encryption: {e}")
        raise # Re-raise the exception

    # --- Combine Nonce and Ciphertext ---
    # Prepend the nonce to the ciphertext+tag. The recipient will need the nonce
    # (which they can extract from the start of the received data) to decrypt.
    full_ciphertext = nonce + ciphertext_and_tag

    return full_ciphertext, {'cle secrete': key}

# AES_BLOCK_SIZE = 128  # bits
# AES_IV_SIZE = 16      # bytes

# def encrypt_aes(message: str, key_size: int = 256, key: bytes = None) -> tuple[bytes, dict]:
#     """
#     Encrypt a message using AES in CBC mode with PKCS7 padding.

#     Args:
#         message (str): The plaintext message to encrypt.
#         key_size (int): The size of the AES key in bits (128, 192, or 256). Default is 256.
#         key (bytes, optional): The AES key. If None, a random key is generated.

#     Returns:
#         tuple[bytes, bytes]: (iv + ciphertext, key used)
#     """
#     if key is None:
#         key = os.urandom(key_size // 8)

#     iv = os.urandom(AES_IV_SIZE)

#     padder = padding.PKCS7(AES_BLOCK_SIZE).padder()
#     padded_data = padder.update(message.encode()) + padder.finalize()

#     cipher = Cipher(algorithms.AES(key), modes.CBC(iv))
#     encryptor = cipher.encryptor()
#     ciphertext = encryptor.update(padded_data) + encryptor.finalize()

#     return iv + ciphertext, {'cle secrete': key}

def encrypt_rsa(message: str, key_size: int = 2048) -> tuple[bytes, dict, dict]:
    """
    Encrypts a string message using RSA.

    Generates a new RSA key pair (public and private) for each call.
    Encrypts the message using the public key with OAEP padding (recommended).

    Args:
        message: The string message to encrypt.
        key_size: The desired RSA key size in bits (e.g., 2048, 3072, 4096).
                  Defaults to 2048. Must be at least 2048 for security.

    Returns:
        A tuple containing:
        - ciphertext (bytes): The encrypted data.
        - keys (dict): A dictionary containing the PEM-encoded public and
                       private keys as strings:
                       {'public_key': str, 'private_key': str}
        - components (dict): A dictionary containing two sub-dictionaries,
                             'public_key' and 'private_key', holding the
                             integer components of the respective keys.
                             'n' and 'e' are included in both for completeness.
                             {'public_key': {'n': int, 'e': int},
                              'private_key': {'p': int, 'q': int, 'd': int,
                                              'n': int, 'e': int, 'dmp1': int,
                                              'dmq1': int, 'iqmp': int}}

    Raises:
        ValueError: If key_size is less than 2048, or if the message is too
                    long to be encrypted with the chosen key size and padding.
    """
    # if key_size < 2048:
    #     raise ValueError("Key size must be at least 2048 bits for RSA security.")

    # --- Key Generation ---
    private_key = rsa.generate_private_key(
        public_exponent=65537, # Standard public exponent
        key_size=key_size,
        backend=default_backend()
    )
    public_key = private_key.public_key()

    # --- Prepare Plaintext ---
    plaintext = message.encode('utf-8')

    # --- Check Message Length ---
    # OAEP padding adds overhead. The maximum message length depends on the
    # key size and the hash algorithm used (SHA256 here).
    # Max length = key_size_bytes - 2 * hash_output_size_bytes - 2
    sha256_hash_len = hashes.SHA256.digest_size # Usually 32 bytes
    max_len = (key_size // 8) - (2 * sha256_hash_len) - 2
    if len(plaintext) > max_len:
        raise ValueError(
            f"Message is too long ({len(plaintext)} bytes) for RSA key size "
            f"{key_size} bits with OAEP padding. Maximum length is {max_len} bytes."
        )

    # --- Encryption ---
    ciphertext = public_key.encrypt(
        plaintext,
        asym_padding.OAEP(
            mgf=asym_padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )

    # --- Serialize Keys to PEM Format ---
    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )

    public_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )

    keys_dict = {
        'cle secrete': private_pem.decode('utf-8'),
        'cle publique': public_pem.decode('utf-8')
    }

    # --- Extract Key Components (Structured) ---
    private_numbers = private_key.private_numbers()
    public_numbers = private_key.public_key().public_numbers() # Get public numbers directly

    public_components = {
        'n': int_to_bytes(public_numbers.n),
        'e': int_to_bytes(public_numbers.e),
    }

    private_components = {
        'p': int_to_bytes(private_numbers.p),
        'q': int_to_bytes(private_numbers.q),
        'd': int_to_bytes(private_numbers.d),
        'n': int_to_bytes(public_numbers.n),  # Duplicated from public for completeness
        'e': int_to_bytes(public_numbers.e),  # Duplicated from public for completeness
        # 'dmp1': private_numbers.dmp1, # d mod (p-1)
        # 'dmq1': private_numbers.dmq1, # d mod (q-1)
        # 'iqmp': private_numbers.iqmp, # q^-1 mod p
    }

    structured_components = {
        'cle publique': public_components,
        'cle secrete': private_components
    }

    return ciphertext, keys_dict, structured_components

# def encrypt_rsa(message: str, key_size: int = 2048) -> tuple[bytes, bytes, dict]:
#     """
#     Encrypt a message using RSA with OAEP padding.

#     Args:
#         message (str): The plaintext message to encrypt.
#         key_size (int): RSA key size in bits (e.g., 2048 or 4096). Default is 2048.

#     Returns:
#         tuple[bytes, bytes, bytes]: (encrypted message, private_key_pem, public_key_pem)
#     """
#     private_key = rsa.generate_private_key(
#         public_exponent=65537,
#         key_size=key_size,
#     )
#     public_key = private_key.public_key()

#     encrypted = public_key.encrypt(
#         message.encode(),
#         asymm_padding.OAEP(
#             mgf=asymm_padding.MGF1(algorithm=hashes.SHA256()),
#             algorithm=hashes.SHA256(),
#             label=None,
#         ),
#     )

#     private_key_pem = private_key.private_bytes(
#         encoding=Encoding.PEM,
#         format=PrivateFormat.PKCS8,
#         encryption_algorithm=NoEncryption(),
#     )

#     public_key_pem = public_key.public_bytes(
#         encoding=Encoding.PEM,
#         format=PublicFormat.SubjectPublicKeyInfo,
#     )
    
#     priv_numbers = private_key.private_numbers()
#     pub_numbers = public_key.public_numbers()
    
#     private_components = {
#         "n": int_to_bytes(priv_numbers.public_numbers.n),
#         "e": int_to_bytes(priv_numbers.public_numbers.e),
#         "d": int_to_bytes(priv_numbers.d),
#         "p": int_to_bytes(priv_numbers.p),
#         "q": int_to_bytes(priv_numbers.q),
#     }

#     public_components = {
#         "n": int_to_bytes(pub_numbers.n),
#         "e": int_to_bytes(pub_numbers.e),
#     }
    
#     keys_pem = {
#         'cle secrete': private_key_pem,
#         'cle publqiue': public_key_pem
#         }
#     keys_elements = {
#         'elements cle secrete': private_components,
#         'elements cle publique': public_components
#         }

#     return encrypted, keys_pem, keys_elements

def compute_hashes(message: str, algorithm) -> dict:
    """
    Compute multiple hashes for a given message in raw binary format.

    Args:
        message (str): The message to hash.

    Returns:
        dict: {hash_name: bytes}
    """
    if algorithm == 'SHA-2 256':
        hash = hashlib.sha256(message.encode()).digest()
    elif algorithm == 'SHA-2 384':
        hash = hashlib.sha384(message.encode()).digest()
    elif algorithm == 'SHA-2 512':
        hash = hashlib.sha512(message.encode()).digest()
    elif algorithm == 'SHA-3 256':
        hash = hashlib.sha3_256(message.encode()).digest()
    elif algorithm == 'SHA-3 384':
        hash = hashlib.sha3_384(message.encode()).digest()
    elif algorithm == 'SHA-3 512':
        hash = hashlib.sha3_512(message.encode()).digest()
    return hash

def encrypt_ecc(message: str, curve_name: str = "SECP 256 R1") -> dict:
    """
    Encrypt a message using ECC + AES hybrid encryption.
    Returns ECC key components and AES encrypted data.

    Args:
        message (str): The plaintext message.
        curve_name (str): ECC curve name. Supported: SECP256R1, SECP384R1, SECP521R1

    Returns:
        dict: {
            'ciphertext': bytes,
            'shared_key': bytes,
            'private_key_pem': bytes,
            'public_key_pem': bytes,
            'private_components': dict,
            'public_components': dict
        }
    """
    curve_map = {
        "SECP 256 R1": ec.SECP256R1(),
        "SECP 384 R1": ec.SECP384R1(),
        "SECP 521 R1": ec.SECP521R1(),
    }

    if curve_name not in curve_map:
        raise ValueError(f"Unsupported curve: {curve_name}")

    curve = curve_map[curve_name]

    # Generate ECC keys
    private_key = ec.generate_private_key(curve)
    public_key = private_key.public_key()

    # Extract key numbers
    priv_numbers = private_key.private_numbers()
    pub_numbers = public_key.public_numbers()

    private_components = {
        'private_value': int_to_bytes(priv_numbers.private_value)
    }

    public_components = {
        'x': int_to_bytes(pub_numbers.x),
        'y': int_to_bytes(pub_numbers.y),
        # 'curve': curve_name
    }

    # Hybrid encryption (AES)
    aes_key = os.urandom(32)  # AES-256 key
    iv = os.urandom(16)

    padder = padding.PKCS7(128).padder()
    padded_data = padder.update(message.encode()) + padder.finalize()

    cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv))
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(padded_data) + encryptor.finalize()

    encrypted_data = iv + ciphertext

    # Simulated shared key (replace with ECDH in real case)
    shared_key = secrets.token_bytes(32)

    keys = {
        'cle publique': public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        ),
        'cle privee': private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption(),
        ),
        # 'cle partage': shared_key
    }
    keys_elements = {
        'elements cle secrete': private_components,
        'elements cle publique': public_components
    }
    return encrypted_data, keys, keys_elements

def encrypt_elgamal(message: str, key_size: int = 2048) -> tuple[dict, dict, dict]:
    """
    Encrypts a short message using the ElGamal cryptosystem.

    Generates new ElGamal parameters (p, g) and a keypair (x, y) for each call.
    NOTE: ElGamal requires the message, when converted to an integer, to be
    less than the prime modulus 'p'. This function will raise an error if the
    message is too long for the chosen key size. It does not implement chunking.

    Args:
        message (str): The plaintext message string to encrypt. Must be short
                       enough to fit within the modulus 'p' when encoded.
        key_size (int): The bit size for the prime modulus 'p'. Determines the
                        maximum message size. Recommended: 2048 or higher.

    Returns:
        tuple: A tuple containing:
        - ciphertext (dict): A dictionary containing the two components of the
                             ElGamal ciphertext as bytes: {'a': bytes, 'b': bytes}.
        - keys (dict): A dictionary containing the public key components needed
                       for encryption (often shared):
                       {'public_key': {'p': int, 'g': int, 'y': int}}
        - components (dict): A dictionary containing the separated public and
                             private key numerical components:
                             {'public_components': {'p': int, 'g': int, 'y': int},
                              'private_components': {'x': int, 'p': int, 'g': int}}

    Raises:
        ValueError: If the message, once converted to an integer, is too large
                    for the generated prime 'p', or if key_size is too small
                    for parameter generation.
        TypeError: If the message is not a string.
    """
    if not isinstance(message, str):
        raise TypeError("Message must be a string.")

    # --- Parameter and Key Generation ---
    # 1. Generate DH parameters to get a suitable prime 'p' and generator 'g'
    #    This is a convenient way to get cryptographically reasonable parameters.
    try:
        parameters = dh.generate_parameters(generator=2, key_size=key_size,
                                            backend=default_backend())
    except ValueError as e:
         raise ValueError(f"Failed to generate DH parameters (key_size {key_size} might be too small or unsupported): {e}")

    p = parameters.parameter_numbers().p
    g = parameters.parameter_numbers().g
    q = parameters.parameter_numbers().q # Often p = 2q + 1, order of subgroup

    # Ensure p and g are available
    if not p or not g:
         raise ValueError("Failed to obtain p and g from DH parameter generation.")

    # 2. Generate Private Key 'x'
    #    x should be in [1, p-2] or [1, q-1] if working in subgroup of order q.
    #    For simplicity, let's use [1, p-2]. Generate enough bytes for p, then reduce.
    num_bytes_p = (p.bit_length() + 7) // 8
    while True:
        x_bytes = os.urandom(num_bytes_p)
        x = int.from_bytes(x_bytes, 'big')
        # Ensure x is in the valid range [1, p-2] - adjust range as needed based on group specifics
        x = x % (p - 2) + 1 # Simple approach to get it in range
        if 1 <= x < p - 1:
              break

    # 3. Calculate Public Key 'y'
    y = pow(g, x, p)

    # --- Message Preparation ---
    # 1. Encode message string to bytes (UTF-8)
    message_bytes = message.encode('utf-8')

    # 2. Convert message bytes to integer M
    M = int.from_bytes(message_bytes, 'big')

    # 3. *** CRUCIAL CHECK ***: Ensure M < p
    if M >= p:
        raise ValueError(
            f"Message is too large ({len(message_bytes)} bytes -> integer M) for "
            f"the prime modulus p ({p.bit_length()} bits). "
            f"Maximum integer value allowed is p-1."
        )
    if M == 0:
        # ElGamal technically works for M=0, but often requires M > 0
        # Depending on implementation/padding, M=0 might be problematic.
        # Let's allow it for now, but be aware.
        pass


    # --- Encryption ---
    # 1. Choose random ephemeral key 'k' in [1, p-2]
    while True:
        k_bytes = os.urandom(num_bytes_p)
        k = int.from_bytes(k_bytes, 'big')
        k = k % (p - 2) + 1 # Simple approach to get it in range
        # Ensure k is relatively prime to p-1? Not strictly needed for basic ElGamal but good practice for some variants/groups
        # For simplicity, we'll just ensure k is in the range [1, p-2]
        if 1 <= k < p - 1:
              break

    # 2. Compute ciphertext components 'a' and 'b'
    a = pow(g, k, p)
    shared_secret_s = pow(y, k, p) # y^k mod p
    b = (M * shared_secret_s) % p  # (M * y^k) mod p

    # --- Format Output ---
    # Convert components a and b to bytes (fixed size based on p)
    byte_len = (p.bit_length() + 7) // 8
    a_bytes = a.to_bytes(byte_len, 'big')
    b_bytes = b.to_bytes(byte_len, 'big')

    ciphertext_dict = {
        'c1': a_bytes,
        'c2': b_bytes
    }

    # Structure keys and components as requested
    public_key_components = {'p': int_to_bytes(p), 'g': int_to_bytes(g), 'y': int_to_bytes(y)}
    private_key_components = {'x': int_to_bytes(x), 'p': int_to_bytes(p), 'g': int_to_bytes(g)} # Include p, g for context

    keys_dict = {
        'cle publique': public_key_components # Public parts needed to encrypt
    }

    components_dict = {
        'cle secrete': private_key_components,
        'cle publique': public_key_components
    }

    return ciphertext_dict, keys_dict, components_dict